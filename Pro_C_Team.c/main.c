#define _CRT_SECURE_NO_WARNINGS

#pragma warning(disable : 6031)

#include <stdio.h>  // 기본
#include <stdlib.h> // 랜덤, 동적
#include <time.h>   // 랜덤
#include <ctype.h>  // 오류 배제, 깃발 // isdigit() : 10진수 / isalpha() : 알파벳

int random(int r) {
	srand(time(NULL));
	return rand() % (r + 1);
} // 0 ~ r

void scan(int* i) {
	scanf("%d", i);
}

void scan2(int* i, int* j) {
	scanf("%d %d", i, j);
}




int main(void)
{
	int cx, cy; // (coordinate x, coordinate y 약자)

	// <I> 배열 크기 받기 (void ScanArraySize(int* a, int* b))

	//scanf cx, cy값 받기
	//cx, cy : (정수, 8 ~ 24), (오류값들 배제), [크기는 편하신대로 정해주세요]



	int** arr = NULL;

	arr = (int**)malloc(sizeof(int*) * cy);

	for (int i = 0; i < cy; i++)
		arr[i] = (int*)malloc(sizeof(int) * cx);

	for (int i = 0; i < cy; i++)
		for (int j = 0; j < cx; j++)
			arr[i][j] = 0;

	// <II> : 지뢰 랜덤 배치 (void RandomMine(int** arr, int cx, int cy))

	// 위에 선언된 random(cx), random(cy)를 이용하여 랜덤한 수 두 개를 고름 (0 ~ cx - 1),(0 ~ cy - 1)
	// 랜덤 좌표를 선정 후, 배열에 지뢰 좌표를 랜덤으로 분포 (arr[y축][x축])
	// 해당되는 좌표(배열)에는 10을 추가하면 됨.
	// 
	// 지뢰의 개수는 (초급: 9 x 9 / 10개 (12.3%) Windows 구 버전 초보 : 8 x 8 / 10개 (15.6%)
	//				중급 : 16 x 16 / 40개 (15.6%) 고급 : 30 x 16 / 99개 (20.6%))로 명시되어 있으며
	// 약 16 ~ 17% 가 적당해보임. ((cx * cy * 4) / 25), [지뢰 개수는 편하신대로 정해주세요]
	//
	// C언어의 랜덤의 성질은 <time.h>로 이루어지므로 같은 숫자가 연달아 배정될 수 있음
	// 즉, 위의 성질로 인해 random(cx)와 random(cy)가 같은 숫자로 배정될 수 있음 (cx, cy가 같은 정사각형 모양일 경우 특히 그럼)
	//
	// 또한, 이미 지정된 좌표로 또 다시 지뢰가 설치될 수 있음. (랜덤이 for문으로 연달아 작동할 때 숫자가 겹침)
	// 이를 방지하여 지뢰 개수만큼 랜덤으로 배치 (골고루 분포되어야 함)
	//
	// 랜덤함수로 좌표 선정을 하는데 소요되는 시간은 오래걸려서 이를 해결할 방안은 연구해야함.



	// <III> : 지뢰 옆 숫자 배치 (void MineCount(int** arr, int cx, int cy))

	// 위에 배열 전체를 0으로 정의해 놓음.
	// 이 중 지뢰(지뢰 = 10)가 랜덤으로 배치되었고,
	// 그 주변 칸들에 0 ~ 8까지로 선언해야함.
	// 
	// 이때, 중앙 부분, 모서리 부분, 꼭짓점 부분을 나누어서 판단
	// 중앙 부분 : 0 ~ 8
	// 모서리 부분 : 0 ~ 5
	// 꼭짓점 부분 : 0 ~ 3



	// <IV> 출력 함수 (void PrintArray(int** arr, int cx, int cy))

	// 배열에 선언될 수 있는 숫자는 다음과 같음,
	// : 0 ~ 8, 10, 50 ~ 58, 60, 100 ~ 108, 110
	//
	// 안보이는 칸 (아직 건드리지 않은 칸)
	// 0 : 빈칸 ([ ])
	// 1 ~ 8 : 숫자 칸 ([ ])
	// 10 : 지뢰 칸 ([ ])
	// 
	// 깃발 칸
	// 50 ~ 58, 60 : 깃발 칸 ([P])
	// 
	// 명시된 칸 (건드린 칸)
	// 100 : 빈칸 (   )
	// 101 ~ 108 : 숫자 칸 ( 1 ), ( 2 ) ...
	// 110 : 지뢰 칸 ( M ) ; 패배
	// 
	// for문과 if문을 사용하여 출력해야함.
	// 
	// 위에 중간점검에서 (   )안에 들어있는 형태로 출력,
	// 배열에 저장되어 있는 해당되는 값에 따라 출력.
	// 
	// 출력된 게임판에 테두리를 만들어주고,
	// 좌표를 상하좌우 전부 표기 (판이 커지면 헷갈림), (1 ~cx, 1 ~cy)
	// 혹은, 좌표를 왼쪽과 아래쪽에만 표기해도 됨. 
	// [플레이어에게 보이는 좌표 표기 범위는 원하시는 대로 해주세요. 가독성 좋은 쪽으로^^]
	//
	// 아래 혹은 위에 남은 지뢰 개수를 표기함. 이때 남은 지뢰 개수는 깃발 수와 비례함
	// 즉, 남은 지뢰 개수가 음수가 될 수도 있음 (깃발을 필요 이상으로 설치하면)
	//
	// 이 함수는 반복해서 출력됨.



	// <V> 좌표 입력 함수 (void PlayerInput(int** arr, int cx, int cy, int px, int py)) ; (player x, player y 약자)

	// 게임을 할 플레이어가 입력할 수 있는 좌표는 
	// cx, cy보다 작은 내부 좌표여야 함. (오류값들 배제)
	// 
	// 또한 빈칸만 입력할 수 있음 (좌표에 해당하는 배열값이 0 ~ 8, 10)
	////////// + 이미 입력된 칸(숫자 혹은 빈칸(100 ~ 108)을 다시 입력하여 발생하는 빠른 진행키는 나머지 함수들의 구현에 성공할 경우 구현해봄.)
	// [일단은 해당 좌표가 (100 ~ 108)에 해당되면 다시 입력하지 못하도록 해주세요. 나중에 구현할 수 있으면 구현하겠습니다.]
	//
	// 플레이어에게 입력받은 좌표에 100을 추가함.
	//
	// 이 함수는 반복해서 출력됨.



	// <VI> 깃발 입력 함수 (void FlagInput(char Flag, int px, int py))

	// "<V> 좌표 입력 함수" 를 포함하는 함수로 "<VI> 깃발 입력 함수" 내부에 "<V> 좌표 입력 함수"가 있다고 보면 됨.
	//
	// 좌표 입력시 'p' 혹은 'P'를 입력하면
	// if문을 통해 갈래가 나뉘어 "<V> 좌표 입력 함수"를 다른 방식으로 실행함. (ctype.h 활용 ; (isalpha), (isdigit))
	// p 1 1 식의 입력 ; 깃발 설치
	// 1 1 식의 입력 ; 좌표 입력
	// 
	// 만약 좌표(정수, px)를 입력하였다면 Flag에 입력된 숫자를 int형으로 바꾸어 px로 대입
	//
	// 깃발 좌표에 다시 깃발을 설치하면 빈칸이 됨 ((50 ~ 58, 60) - 50 = (0 ~ 8), 10)
	//
	// 이 함수는 반복해서 출력됨.




	// <VII> 게임 시작 예외 제거 함수 (void StartError(int** arr, int cx, int cy, int px, int py))

	// 앞서 말했듯이 랜덤함수는 불러오는데 시간이 꽤 소요됨.
	// 이로 인해서 ; 플레이어가 먼저 게임판의 크기를 입력 후, 그에 따른 지뢰 배치는 굉장히 지루할 수 있음.
	// 또한 게임판의 크기를 입력 후 20%에 가까운 지뢰를 불운하게도 처음 선택하면 실력이 아닌 운에 좌우되는 게임이 되어버림.
	// 게다가 다시 게임을 불러오는 데 소요되는 시간이 너무 큼.
	// 
	// 물론, 지뢰 배치를 먼저하는 상황에 소요되는 시간도 같지만 이 방법이 더 나을 것 같아 선택함. [더 좋은 선택지가 있으면 말해주세요]
	//
	// 게임을 시작하고 아무칸도 건드리지 않은 첫 입력 상황에서
	// 처음 입력되는 좌표와 그 주변 8칸은 지뢰가 없는 '빈칸'으로 치환되며,
	// 처음 입력되는 좌표와 그 주변 8칸에 있었던 지뢰의 갯수만큼 
	// 지뢰를 처음 입력되는 좌표와 그 주변 8칸을 제외한 나머지 구역에 재배치함. (최소 0개, 최대 9개 재배치)
	// 
	// 이때 모서리와 꼭짓점은 주변이 8칸이 아니므로 예외성이 필요함.
	//
	// 게임을 시작하게 되면 초반값을 재설정한 후에
	// "<III> : 지뢰 옆 숫자 배치"를 호출.



	// <VIII> 패배 조건 함수 (void loseShow(int**a, int cx, int cy))

	// 어느 배열이든 '110'이 되면 지뢰칸(10)에 100을 더해서
	// 지뢰 위치를 알려주고 게임은 종료됨. ('exit(0);' 을 활용함)
	//
	// "<IV> 출력 함수" 에서 if (arr[y][x] == 110)과 연계되어 작동함.



	// <IX> 승리 조건 함수 (main 함수 선언 예정)

	// for문을 통해 반복할 함수들을 반복함과 동시에
	// (cx * cy - (지뢰 개수))만큼 좌표를 입력하는데 성공했다면 승리함.
	// 
	// 최종적으로는 "<VIII> 패배 조건 함수" 의 일부를 활용하여 지뢰 위치를 보여주며
	// 승리하였음을 알려줌.


	return 0;
}